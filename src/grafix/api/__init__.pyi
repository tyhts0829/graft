# This file is auto-generated by tools/gen_g_stubs.py. DO NOT EDIT.
# Regenerate with: python -m tools.gen_g_stubs

# ruff: noqa: F401, E402

from __future__ import annotations

from collections.abc import Callable, Sequence
from pathlib import Path
from typing import Any, Protocol, TypeAlias

from grafix.core.geometry import Geometry
from grafix.core.layer import Layer
from grafix.core.scene import SceneItem

Vec3: TypeAlias = tuple[float, float, float]

class _G(Protocol):
    def __call__(self, name: str | None = None) -> _G:
        """ラベル付き primitive 名前空間を返す。"""
        ...
    def grid(self, *, nx: int = ..., ny: int = ..., center: Vec3 = ..., scale: float = ...) -> Geometry:
        """
        グリッド（縦線 nx 本 + 横線 ny 本）を生成する。

        引数:
            nx: 縦線の本数
            ny: 横線の本数
            center: 平行移動ベクトル (cx, cy, cz)
            scale: 等方スケール倍率 s
        """
        ...
    def line(self, *, center: Vec3 = ..., length: float = ..., angle: float = ...) -> Geometry:
        """
        正規化済み引数から線分を生成する。

        引数:
            center: 線分中心の座標 (cx, cy, cz)
            length: 線分の長さ
            angle: 回転角 [deg]
        """
        ...
    def polygon(self, *, n_sides: int = ..., phase: float = ..., center: Vec3 = ..., scale: float = ...) -> Geometry:
        """
        正多角形の閉ポリラインを生成する。

        引数:
            n_sides: 辺の数
            phase: 頂点開始角 [deg]
            center: 平行移動ベクトル (cx, cy, cz)
            scale: 等方スケール倍率 s
        """
        ...
    def polyhedron(self, *, type_index: int = ..., center: Vec3 = ..., scale: float = ...) -> Geometry:
        """
        正多面体を面ポリライン列として生成する。

        引数:
            type_index: 形状の選択インデックス（0..N-1）
            center: 平行移動ベクトル (cx, cy, cz)
            scale: 等方スケール倍率 s
        """
        ...
    def sphere(self, *, subdivisions: int = ..., type_index: int = ..., mode: int = ..., center: Vec3 = ..., scale: float = ...) -> Geometry:
        """
        球のワイヤーフレームをポリライン列として生成する。

        引数:
            subdivisions: 細分化レベル（0..5 にクランプ）
            type_index: スタイル選択（0..3 にクランプ）
            mode: latlon/rings 用の線種（0: 横/緯度のみ, 1: 縦/経度のみ, 2: 両方）
            center: 平行移動ベクトル (cx, cy, cz)
            scale: 等方スケール倍率 s
        """
        ...
    def text(self, *, text: str = ..., font: str = ..., font_index: int = ..., text_align: str = ..., letter_spacing_em: float = ..., line_height: float = ..., quality: float = ..., center: Vec3 = ..., scale: float = ...) -> Geometry:
        """
        フォントアウトラインからテキストのポリライン列を生成する。

        引数:
            text: 描画する文字列
            font: フォント指定（実在パス / ファイル名 / ステム / 部分一致）
            font_index: `.ttc` の subfont 番号（0 以上）
            text_align: 行揃え（`left|center|right`）
            letter_spacing_em: 文字間の追加スペーシング（em 比）
            line_height: 行送り（em 比）
            quality: 平坦化品質（0..1）
            center: 平行移動ベクトル (cx, cy, cz)
            scale: 等方スケール倍率 s
        """
        ...
    def torus(self, *, major_radius: float = ..., minor_radius: float = ..., major_segments: int = ..., minor_segments: int = ..., center: Vec3 = ..., scale: float = ...) -> Geometry:
        """
        トーラスのワイヤーフレーム（子午線+緯線）を生成する。

        引数:
            major_radius: 大半径
            minor_radius: 小半径
            major_segments: major 方向の分割数
            minor_segments: minor 方向の分割数
            center: 平行移動ベクトル (cx, cy, cz)
            scale: 等方スケール倍率 s
        """
        ...

class _EffectBuilder(Protocol):
    def __call__(self, geometry: Geometry, *more_geometries: Geometry) -> Geometry:
        """保持している effect 列を Geometry に適用する。"""
        ...
    def affine(self, *, bypass: bool = ..., auto_center: bool = ..., pivot: Vec3 = ..., rotation: Vec3 = ..., scale: Vec3 = ..., delta: Vec3 = ...) -> _EffectBuilder:
        """
        スケール→回転→平行移動を適用する（合成アフィン変換）。

        引数:
            bypass: bool
            auto_center: True なら頂点の平均座標を中心に使用する
            pivot: `auto_center=False` のときの変換中心
            rotation: 各軸の回転角 [deg]（rx, ry, rz）
            scale: 各軸の倍率（sx, sy, sz）
            delta: 最後に適用する平行移動量 [mm]（dx, dy, dz）
        """
        ...
    def buffer(self, *, bypass: bool = ..., join: str = ..., distance: float = ..., quad_segs: int = ..., keep_original: bool = ...) -> _EffectBuilder:
        """
        Shapely の buffer を用いて輪郭を生成する。

        引数:
            bypass: bool
            join: 角の処理
            distance: buffer 距離 [mm]
            quad_segs: 円弧近似分割数（Shapely の `quad_segs` 相当）
            keep_original: True のとき buffer 結果に加えて元のポリラインも出力に含める
        """
        ...
    def clip(self, *, bypass: bool = ..., mode: str = ..., draw_outline: bool = ...) -> _EffectBuilder:
        """
        XY 平面へ整列した上で、閉曲線マスクで線分列をクリップする。

        引数:
            bypass: bool
            mode: `"inside"` はマスク内側だけ残す
            draw_outline: True のとき、マスク輪郭を追加で出力に含める
        """
        ...
    def collapse(self, *, bypass: bool = ..., intensity: float = ..., subdivisions: int = ...) -> _EffectBuilder:
        """
        線分を細分化してノイズで崩す（非接続）。

        引数:
            bypass: bool
            intensity: 変位量（長さ単位は座標系に従う）
            subdivisions: 細分回数
        """
        ...
    def dash(self, *, bypass: bool = ..., dash_length: float | Sequence[float] = ..., gap_length: float | Sequence[float] = ..., offset: float | Sequence[float] = ..., offset_jitter: float = ...) -> _EffectBuilder:
        """
        連続線を破線に変換する。

        引数:
            bypass: bool
            dash_length: ダッシュ（描画区間）の長さ [mm]
            gap_length: ギャップ（非描画区間）の長さ [mm]
            offset: パターン位相オフセット [mm]
            offset_jitter: ポリラインごとに offset に加えるジッター量 [mm]
        """
        ...
    def displace(self, *, bypass: bool = ..., amplitude: Vec3 = ..., spatial_freq: Vec3 = ..., amplitude_gradient: Vec3 = ..., frequency_gradient: Vec3 = ..., min_gradient_factor: float = ..., max_gradient_factor: float = ..., t: float = ...) -> _EffectBuilder:
        """
        3D Perlin ノイズで頂点を変位する。

        引数:
            bypass: bool
            amplitude: 変位量 [mm]（各軸別）
            spatial_freq: 空間周波数（各軸別）
            amplitude_gradient: 振幅の軸方向グラデーション係数（各軸別）
            frequency_gradient: 周波数の軸方向グラデーション係数（各軸別）
            min_gradient_factor: 勾配適用時の最小係数（0.0–1.0）
            max_gradient_factor: 勾配適用時の最大係数（1.0–4.0）
            t: 時間オフセット（位相）
        """
        ...
    def drop(self, *, bypass: bool = ..., interval: int = ..., index_offset: int = ..., min_length: float = ..., max_length: float = ..., probability_base: Vec3 = ..., probability_slope: Vec3 = ..., by: str = ..., keep_mode: str = ..., seed: int = ...) -> _EffectBuilder:
        """
        線や面を条件で間引く。

        引数:
            bypass: bool
            interval: 線インデックスに対する間引きステップ
            index_offset: interval 判定の開始オフセット
            min_length: この長さ以下の線を対象とする
            max_length: この長さ以上の線を対象とする
            probability_base: ジオメトリ bbox の中心（正規化座標 t=0）における drop 確率（軸別）
            probability_slope: 正規化座標 t∈[-1,+1] に対する確率勾配（軸別）
            by: 判定単位
            keep_mode: "drop": 条件に一致した線を捨てる
            seed: probability_* 使用時の乱数シード
        """
        ...
    def extrude(self, *, bypass: bool = ..., delta: Vec3 = ..., scale: float = ..., subdivisions: int = ..., center_mode: str = ...) -> _EffectBuilder:
        """
        指定方向に押し出し、複製線と側面エッジを生成する。

        引数:
            bypass: bool
            delta: 押し出し量（dx, dy, dz）[mm]（長さは 0–200 にクランプ）
            scale: 複製線に適用するスケール係数（0–3 にクランプ）
            subdivisions: 中点挿入の細分回数（0–8 にクランプ）
            center_mode: "auto" のとき複製線の重心中心でスケールし、それ以外は原点中心でスケールする
        """
        ...
    def fill(self, *, bypass: bool = ..., angle_sets: int | Sequence[int] = ..., angle: float | Sequence[float] = ..., density: float | Sequence[float] = ..., spacing_gradient: float | Sequence[float] = ..., remove_boundary: bool | Sequence[bool] = ...) -> _EffectBuilder:
        """
        閉領域をハッチングで塗りつぶす。

        引数:
            bypass: bool
            angle_sets: 方向本数（シーケンス指定時はグループごとにサイクル適用）
            angle: 基準角 [deg]（シーケンス指定時はグループごとにサイクル適用）
            density: 旧仕様の密度スケール（シーケンス指定時はグループごとにサイクル適用）
            spacing_gradient: スキャン方向に沿った線間隔勾配（シーケンス指定時はグループごとにサイクル適用）
            remove_boundary: True なら入力境界（入力ポリライン）を出力から除去する（シーケンス指定時はグループごとにサイクル適用）
        """
        ...
    def mirror(self, *, bypass: bool = ..., n_mirror: int = ..., cx: float = ..., cy: float = ..., source_positive_x: bool = ..., source_positive_y: bool = ..., show_planes: bool = ...) -> _EffectBuilder:
        """
        XY 平面でのミラー複製を行う。

        引数:
            bypass: bool
            n_mirror: 1: x=cx による半空間ミラー
            cx: float, range [-100.0, 100.0]
            cy: float, range [-100.0, 100.0]
            source_positive_x: n_mirror=1/2 のときの x 側ソース選択
            source_positive_y: n_mirror=2 のときの y 側ソース選択
            show_planes: 対称面（または放射状境界）を可視化用ラインとして出力へ追加する
        """
        ...
    def mirror3d(self, *, bypass: bool = ..., mode: str = ..., n_azimuth: int = ..., center: Vec3 = ..., axis: Vec3 = ..., phi0: float = ..., mirror_equator: bool = ..., source_side: bool = ..., group: str = ..., use_reflection: bool = ..., show_planes: bool = ...) -> _EffectBuilder:
        """
        3D 放射状ミラー（azimuth / polyhedral）。

        引数:
            bypass: bool
            mode: "azimuth" は回転軸を含む 2 平面でくさびを作り、回転と反射で複製する
            n_azimuth: "azimuth" の等分数
            center: 回転/反射の中心
            axis: "azimuth" の回転軸
            phi0: くさびの開始角 [deg]（"azimuth" のみ）
            mirror_equator: 赤道面（axis ⟂）でさらにミラーする（"azimuth" のみ）
            source_side: mirror_equator=True のときのソース側
            group: "polyhedral" の回転群（T=12, O=24, I=60）
            use_reflection: "polyhedral" で代表反射（y=0）を追加して倍化する
            show_planes: 対称面を可視化用の十字線として出力に追加する
        """
        ...
    def partition(self, *, bypass: bool = ..., mode: str = ..., site_count: int = ..., seed: int = ..., site_density_base: Vec3 = ..., site_density_slope: Vec3 = ..., auto_center: bool = ..., pivot: Vec3 = ...) -> _EffectBuilder:
        """
        偶奇規則の平面領域を Voronoi 分割し、閉ループ群を返す。

        引数:
            bypass: bool
            mode: 入力リングの扱い
            site_count: Voronoi のサイト数
            seed: 乱数シード（再現性）
            site_density_base: サイト密度（採用確率）の中心値（軸別）
            site_density_slope: 正規化座標 t∈[-1,+1] に対する密度勾配（軸別）
            auto_center: True のとき `pivot` を無視し、入力 bbox の中心を pivot として扱う
            pivot: auto_center=False のときの pivot（ワールド座標）
        """
        ...
    def quantize(self, *, bypass: bool = ..., step: Vec3 = ...) -> _EffectBuilder:
        """
        頂点座標を各軸のステップ幅で量子化する（XYZ）。

        引数:
            bypass: bool
            step: 各軸の格子間隔 (sx, sy, sz)
        """
        ...
    def relax(self, *, bypass: bool = ..., relaxation_iterations: int = ..., step: float = ...) -> _EffectBuilder:
        """
        線分ネットワークをグラフとして弾性緩和する。

        引数:
            bypass: bool
            relaxation_iterations: 反復回数（0–50 にクランプ）
            step: 1 ステップの移動係数（0.0–0.5 にクランプ）
        """
        ...
    def repeat(self, *, bypass: bool = ..., count: int = ..., cumulative_scale: bool = ..., cumulative_offset: bool = ..., cumulative_rotate: bool = ..., offset: Vec3 = ..., rotation_step: Vec3 = ..., scale: Vec3 = ..., curve: float = ..., auto_center: bool = ..., pivot: Vec3 = ...) -> _EffectBuilder:
        """
        入力ジオメトリを複製して、規則的な配列を作る。

        引数:
            bypass: bool
            count: 複製回数
            cumulative_scale: True のときスケール補間にカーブ（t' = t**curve）を用いる
            cumulative_offset: True のときオフセット補間にカーブ（t' = t**curve）を用いる
            cumulative_rotate: True のとき回転補間にカーブ（t' = t**curve）を用いる
            offset: 終点オフセット [mm]
            rotation_step: 終点回転角 [deg]（rx, ry, rz）
            scale: 終点スケール倍率（sx, sy, sz）
            curve: カーブ係数
            auto_center: True なら平均座標を中心に使用
            pivot: `auto_center=False` のときの変換中心 [mm]
        """
        ...
    def rotate(self, *, bypass: bool = ..., auto_center: bool = ..., pivot: Vec3 = ..., rotation: Vec3 = ...) -> _EffectBuilder:
        """
        回転（auto_center / pivot 対応、degree 入力）。

        引数:
            bypass: bool
            auto_center: True なら頂点の平均座標を中心に使用
            pivot: 回転の中心（`auto_center=False` のとき有効）
            rotation: 各軸の回転角 [deg]（rx, ry, rz）
        """
        ...
    def scale(self, *, bypass: bool = ..., mode: str = ..., auto_center: bool = ..., pivot: Vec3 = ..., scale: Vec3 = ...) -> _EffectBuilder:
        """
        スケール変換を適用（auto_center 対応）。

        引数:
            bypass: bool
            mode: `"all"` は入力全体を 1 つの中心でスケールする
            auto_center: True なら平均座標を中心に使用
            pivot: 変換の中心（`mode="all"` かつ `auto_center=False` のとき有効）
            scale: 各軸の倍率
        """
        ...
    def subdivide(self, *, bypass: bool = ..., subdivisions: int = ...) -> _EffectBuilder:
        """
        中点挿入で線を細分化する。

        引数:
            bypass: bool
            subdivisions: 細分回数
        """
        ...
    def translate(self, *, bypass: bool = ..., delta: Vec3 = ...) -> _EffectBuilder:
        """
        平行移動（XYZ のオフセット加算）。

        引数:
            bypass: bool
            delta: 平行移動量（dx, dy, dz）
        """
        ...
    def trim(self, *, bypass: bool = ..., start_param: float = ..., end_param: float = ...) -> _EffectBuilder:
        """
        ポリライン列を正規化弧長の区間でトリムする。

        引数:
            bypass: bool
            start_param: 開始位置（0.0–1.0）
            end_param: 終了位置（0.0–1.0）
        """
        ...
    def twist(self, *, bypass: bool = ..., auto_center: bool = ..., pivot: Vec3 = ..., angle: float = ..., axis_dir: Vec3 = ...) -> _EffectBuilder:
        """
        位置に応じて軸回りにねじる（中心付近は 0）。

        引数:
            bypass: bool
            auto_center: True なら平均座標を回転中心に使用
            pivot: ねじり軸（`axis_dir` に平行な直線）の通過点（`auto_center=False` のとき有効）
            angle: 最大ねじれ角 [deg]
            axis_dir: ねじり軸方向（ベクトル）
        """
        ...
    def weave(self, *, bypass: bool = ..., num_candidate_lines: int = ..., relaxation_iterations: int = ..., step: float = ...) -> _EffectBuilder:
        """
        入力閉曲線からウェブ状の線分ネットワークを生成する。

        引数:
            bypass: bool
            num_candidate_lines: 候補線本数（0–500 にクランプ）
            relaxation_iterations: 弾性緩和の反復回数（0–50 にクランプ）
            step: 1 ステップの移動係数（0.0–0.5 にクランプ）
        """
        ...
    def wobble(self, *, bypass: bool = ..., amplitude: Vec3 = ..., frequency: Vec3 = ..., phase: float = ...) -> _EffectBuilder:
        """
        各頂点へサイン波由来の変位を加える。

        引数:
            bypass: bool
            amplitude: 変位量 [mm] 相当（各軸別）
            frequency: 空間周波数（各軸別）
            phase: 位相 [deg]
        """
        ...

class _E(Protocol):
    def __call__(self, name: str | None = None) -> _E:
        """ラベル付き effect 名前空間を返す。"""
        ...
    def affine(self, *, bypass: bool = ..., auto_center: bool = ..., pivot: Vec3 = ..., rotation: Vec3 = ..., scale: Vec3 = ..., delta: Vec3 = ...) -> _EffectBuilder:
        """
        スケール→回転→平行移動を適用する（合成アフィン変換）。

        引数:
            bypass: bool
            auto_center: True なら頂点の平均座標を中心に使用する
            pivot: `auto_center=False` のときの変換中心
            rotation: 各軸の回転角 [deg]（rx, ry, rz）
            scale: 各軸の倍率（sx, sy, sz）
            delta: 最後に適用する平行移動量 [mm]（dx, dy, dz）
        """
        ...
    def buffer(self, *, bypass: bool = ..., join: str = ..., distance: float = ..., quad_segs: int = ..., keep_original: bool = ...) -> _EffectBuilder:
        """
        Shapely の buffer を用いて輪郭を生成する。

        引数:
            bypass: bool
            join: 角の処理
            distance: buffer 距離 [mm]
            quad_segs: 円弧近似分割数（Shapely の `quad_segs` 相当）
            keep_original: True のとき buffer 結果に加えて元のポリラインも出力に含める
        """
        ...
    def clip(self, *, bypass: bool = ..., mode: str = ..., draw_outline: bool = ...) -> _EffectBuilder:
        """
        XY 平面へ整列した上で、閉曲線マスクで線分列をクリップする。

        引数:
            bypass: bool
            mode: `"inside"` はマスク内側だけ残す
            draw_outline: True のとき、マスク輪郭を追加で出力に含める
        """
        ...
    def collapse(self, *, bypass: bool = ..., intensity: float = ..., subdivisions: int = ...) -> _EffectBuilder:
        """
        線分を細分化してノイズで崩す（非接続）。

        引数:
            bypass: bool
            intensity: 変位量（長さ単位は座標系に従う）
            subdivisions: 細分回数
        """
        ...
    def dash(self, *, bypass: bool = ..., dash_length: float | Sequence[float] = ..., gap_length: float | Sequence[float] = ..., offset: float | Sequence[float] = ..., offset_jitter: float = ...) -> _EffectBuilder:
        """
        連続線を破線に変換する。

        引数:
            bypass: bool
            dash_length: ダッシュ（描画区間）の長さ [mm]
            gap_length: ギャップ（非描画区間）の長さ [mm]
            offset: パターン位相オフセット [mm]
            offset_jitter: ポリラインごとに offset に加えるジッター量 [mm]
        """
        ...
    def displace(self, *, bypass: bool = ..., amplitude: Vec3 = ..., spatial_freq: Vec3 = ..., amplitude_gradient: Vec3 = ..., frequency_gradient: Vec3 = ..., min_gradient_factor: float = ..., max_gradient_factor: float = ..., t: float = ...) -> _EffectBuilder:
        """
        3D Perlin ノイズで頂点を変位する。

        引数:
            bypass: bool
            amplitude: 変位量 [mm]（各軸別）
            spatial_freq: 空間周波数（各軸別）
            amplitude_gradient: 振幅の軸方向グラデーション係数（各軸別）
            frequency_gradient: 周波数の軸方向グラデーション係数（各軸別）
            min_gradient_factor: 勾配適用時の最小係数（0.0–1.0）
            max_gradient_factor: 勾配適用時の最大係数（1.0–4.0）
            t: 時間オフセット（位相）
        """
        ...
    def drop(self, *, bypass: bool = ..., interval: int = ..., index_offset: int = ..., min_length: float = ..., max_length: float = ..., probability_base: Vec3 = ..., probability_slope: Vec3 = ..., by: str = ..., keep_mode: str = ..., seed: int = ...) -> _EffectBuilder:
        """
        線や面を条件で間引く。

        引数:
            bypass: bool
            interval: 線インデックスに対する間引きステップ
            index_offset: interval 判定の開始オフセット
            min_length: この長さ以下の線を対象とする
            max_length: この長さ以上の線を対象とする
            probability_base: ジオメトリ bbox の中心（正規化座標 t=0）における drop 確率（軸別）
            probability_slope: 正規化座標 t∈[-1,+1] に対する確率勾配（軸別）
            by: 判定単位
            keep_mode: "drop": 条件に一致した線を捨てる
            seed: probability_* 使用時の乱数シード
        """
        ...
    def extrude(self, *, bypass: bool = ..., delta: Vec3 = ..., scale: float = ..., subdivisions: int = ..., center_mode: str = ...) -> _EffectBuilder:
        """
        指定方向に押し出し、複製線と側面エッジを生成する。

        引数:
            bypass: bool
            delta: 押し出し量（dx, dy, dz）[mm]（長さは 0–200 にクランプ）
            scale: 複製線に適用するスケール係数（0–3 にクランプ）
            subdivisions: 中点挿入の細分回数（0–8 にクランプ）
            center_mode: "auto" のとき複製線の重心中心でスケールし、それ以外は原点中心でスケールする
        """
        ...
    def fill(self, *, bypass: bool = ..., angle_sets: int | Sequence[int] = ..., angle: float | Sequence[float] = ..., density: float | Sequence[float] = ..., spacing_gradient: float | Sequence[float] = ..., remove_boundary: bool | Sequence[bool] = ...) -> _EffectBuilder:
        """
        閉領域をハッチングで塗りつぶす。

        引数:
            bypass: bool
            angle_sets: 方向本数（シーケンス指定時はグループごとにサイクル適用）
            angle: 基準角 [deg]（シーケンス指定時はグループごとにサイクル適用）
            density: 旧仕様の密度スケール（シーケンス指定時はグループごとにサイクル適用）
            spacing_gradient: スキャン方向に沿った線間隔勾配（シーケンス指定時はグループごとにサイクル適用）
            remove_boundary: True なら入力境界（入力ポリライン）を出力から除去する（シーケンス指定時はグループごとにサイクル適用）
        """
        ...
    def mirror(self, *, bypass: bool = ..., n_mirror: int = ..., cx: float = ..., cy: float = ..., source_positive_x: bool = ..., source_positive_y: bool = ..., show_planes: bool = ...) -> _EffectBuilder:
        """
        XY 平面でのミラー複製を行う。

        引数:
            bypass: bool
            n_mirror: 1: x=cx による半空間ミラー
            cx: float, range [-100.0, 100.0]
            cy: float, range [-100.0, 100.0]
            source_positive_x: n_mirror=1/2 のときの x 側ソース選択
            source_positive_y: n_mirror=2 のときの y 側ソース選択
            show_planes: 対称面（または放射状境界）を可視化用ラインとして出力へ追加する
        """
        ...
    def mirror3d(self, *, bypass: bool = ..., mode: str = ..., n_azimuth: int = ..., center: Vec3 = ..., axis: Vec3 = ..., phi0: float = ..., mirror_equator: bool = ..., source_side: bool = ..., group: str = ..., use_reflection: bool = ..., show_planes: bool = ...) -> _EffectBuilder:
        """
        3D 放射状ミラー（azimuth / polyhedral）。

        引数:
            bypass: bool
            mode: "azimuth" は回転軸を含む 2 平面でくさびを作り、回転と反射で複製する
            n_azimuth: "azimuth" の等分数
            center: 回転/反射の中心
            axis: "azimuth" の回転軸
            phi0: くさびの開始角 [deg]（"azimuth" のみ）
            mirror_equator: 赤道面（axis ⟂）でさらにミラーする（"azimuth" のみ）
            source_side: mirror_equator=True のときのソース側
            group: "polyhedral" の回転群（T=12, O=24, I=60）
            use_reflection: "polyhedral" で代表反射（y=0）を追加して倍化する
            show_planes: 対称面を可視化用の十字線として出力に追加する
        """
        ...
    def partition(self, *, bypass: bool = ..., mode: str = ..., site_count: int = ..., seed: int = ..., site_density_base: Vec3 = ..., site_density_slope: Vec3 = ..., auto_center: bool = ..., pivot: Vec3 = ...) -> _EffectBuilder:
        """
        偶奇規則の平面領域を Voronoi 分割し、閉ループ群を返す。

        引数:
            bypass: bool
            mode: 入力リングの扱い
            site_count: Voronoi のサイト数
            seed: 乱数シード（再現性）
            site_density_base: サイト密度（採用確率）の中心値（軸別）
            site_density_slope: 正規化座標 t∈[-1,+1] に対する密度勾配（軸別）
            auto_center: True のとき `pivot` を無視し、入力 bbox の中心を pivot として扱う
            pivot: auto_center=False のときの pivot（ワールド座標）
        """
        ...
    def quantize(self, *, bypass: bool = ..., step: Vec3 = ...) -> _EffectBuilder:
        """
        頂点座標を各軸のステップ幅で量子化する（XYZ）。

        引数:
            bypass: bool
            step: 各軸の格子間隔 (sx, sy, sz)
        """
        ...
    def relax(self, *, bypass: bool = ..., relaxation_iterations: int = ..., step: float = ...) -> _EffectBuilder:
        """
        線分ネットワークをグラフとして弾性緩和する。

        引数:
            bypass: bool
            relaxation_iterations: 反復回数（0–50 にクランプ）
            step: 1 ステップの移動係数（0.0–0.5 にクランプ）
        """
        ...
    def repeat(self, *, bypass: bool = ..., count: int = ..., cumulative_scale: bool = ..., cumulative_offset: bool = ..., cumulative_rotate: bool = ..., offset: Vec3 = ..., rotation_step: Vec3 = ..., scale: Vec3 = ..., curve: float = ..., auto_center: bool = ..., pivot: Vec3 = ...) -> _EffectBuilder:
        """
        入力ジオメトリを複製して、規則的な配列を作る。

        引数:
            bypass: bool
            count: 複製回数
            cumulative_scale: True のときスケール補間にカーブ（t' = t**curve）を用いる
            cumulative_offset: True のときオフセット補間にカーブ（t' = t**curve）を用いる
            cumulative_rotate: True のとき回転補間にカーブ（t' = t**curve）を用いる
            offset: 終点オフセット [mm]
            rotation_step: 終点回転角 [deg]（rx, ry, rz）
            scale: 終点スケール倍率（sx, sy, sz）
            curve: カーブ係数
            auto_center: True なら平均座標を中心に使用
            pivot: `auto_center=False` のときの変換中心 [mm]
        """
        ...
    def rotate(self, *, bypass: bool = ..., auto_center: bool = ..., pivot: Vec3 = ..., rotation: Vec3 = ...) -> _EffectBuilder:
        """
        回転（auto_center / pivot 対応、degree 入力）。

        引数:
            bypass: bool
            auto_center: True なら頂点の平均座標を中心に使用
            pivot: 回転の中心（`auto_center=False` のとき有効）
            rotation: 各軸の回転角 [deg]（rx, ry, rz）
        """
        ...
    def scale(self, *, bypass: bool = ..., mode: str = ..., auto_center: bool = ..., pivot: Vec3 = ..., scale: Vec3 = ...) -> _EffectBuilder:
        """
        スケール変換を適用（auto_center 対応）。

        引数:
            bypass: bool
            mode: `"all"` は入力全体を 1 つの中心でスケールする
            auto_center: True なら平均座標を中心に使用
            pivot: 変換の中心（`mode="all"` かつ `auto_center=False` のとき有効）
            scale: 各軸の倍率
        """
        ...
    def subdivide(self, *, bypass: bool = ..., subdivisions: int = ...) -> _EffectBuilder:
        """
        中点挿入で線を細分化する。

        引数:
            bypass: bool
            subdivisions: 細分回数
        """
        ...
    def translate(self, *, bypass: bool = ..., delta: Vec3 = ...) -> _EffectBuilder:
        """
        平行移動（XYZ のオフセット加算）。

        引数:
            bypass: bool
            delta: 平行移動量（dx, dy, dz）
        """
        ...
    def trim(self, *, bypass: bool = ..., start_param: float = ..., end_param: float = ...) -> _EffectBuilder:
        """
        ポリライン列を正規化弧長の区間でトリムする。

        引数:
            bypass: bool
            start_param: 開始位置（0.0–1.0）
            end_param: 終了位置（0.0–1.0）
        """
        ...
    def twist(self, *, bypass: bool = ..., auto_center: bool = ..., pivot: Vec3 = ..., angle: float = ..., axis_dir: Vec3 = ...) -> _EffectBuilder:
        """
        位置に応じて軸回りにねじる（中心付近は 0）。

        引数:
            bypass: bool
            auto_center: True なら平均座標を回転中心に使用
            pivot: ねじり軸（`axis_dir` に平行な直線）の通過点（`auto_center=False` のとき有効）
            angle: 最大ねじれ角 [deg]
            axis_dir: ねじり軸方向（ベクトル）
        """
        ...
    def weave(self, *, bypass: bool = ..., num_candidate_lines: int = ..., relaxation_iterations: int = ..., step: float = ...) -> _EffectBuilder:
        """
        入力閉曲線からウェブ状の線分ネットワークを生成する。

        引数:
            bypass: bool
            num_candidate_lines: 候補線本数（0–500 にクランプ）
            relaxation_iterations: 弾性緩和の反復回数（0–50 にクランプ）
            step: 1 ステップの移動係数（0.0–0.5 にクランプ）
        """
        ...
    def wobble(self, *, bypass: bool = ..., amplitude: Vec3 = ..., frequency: Vec3 = ..., phase: float = ...) -> _EffectBuilder:
        """
        各頂点へサイン波由来の変位を加える。

        引数:
            bypass: bool
            amplitude: 変位量 [mm] 相当（各軸別）
            frequency: 空間周波数（各軸別）
            phase: 位相 [deg]
        """
        ...

class _L(Protocol):
    def __call__(
        self,
        geometry_or_list: Geometry | Sequence[Geometry],
        *,
        color: Vec3 | None = ...,
        thickness: float | None = ...,
        name: str | None = ...,
    ) -> list[Layer]:
        """単体/複数の Geometry から Layer を生成する。"""
        ...

G: _G
E: _E
L: _L

from grafix.api.export import Export as Export
from grafix.core.effect_registry import effect as effect
from grafix.core.primitive_registry import primitive as primitive

def run(
    draw: Callable[[float], SceneItem],
    *,
    config_path: str | Path | None = ...,
    background_color: Vec3 = ...,
    line_thickness: float = ...,
    line_color: Vec3 = ...,
    render_scale: float = ...,
    canvas_size: tuple[int, int] = ...,
    parameter_gui: bool = ...,
    parameter_persistence: bool = ...,
    midi_port_name: str | None = ...,
    midi_mode: str = ...,
    n_worker: int = ...,
    fps: float = ...,
) -> None:
    """pyglet ウィンドウを生成し `draw(t)` のシーンをリアルタイム描画する。"""
    ...

__all__ = ['E', 'Export', 'G', 'L', 'effect', 'primitive', 'run']
